% pdf/a 
\begin{filecontents*}[overwrite]{\jobname.xmpdata}
    \Title{Önálló laboratórium 2 dolgozat}
    \Author{Szilágyi Gábor}
    \Language{hu-HU}
    \Subject{Modell-redukció alkalmazása az elektromágneses térszámításban}
    \Keywords{POD}
    \Publisher{Szilágyi Gábor}
\end{filecontents*}

\documentclass[a4paper,12pt,titlepage]{article}
\usepackage{ucs}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[magyar]{babel}
\usepackage{amsfonts}
\usepackage{amsmath,bm}
\usepackage{amssymb}
\usepackage{graphicx}
%\usepackage[hang]{caption}
\usepackage{subcaption}
%\usepackage{enumerate}
%\usepackage{psfrag}
\usepackage[left=20mm,right=20mm,top=20mm,bottom=25mm]{geometry}
%\usepackage[left=10mm,right=10mm,top=10mm,bottom=15mm]{geometry} %landscape
%\usepackage[hyphenbreaks]{breakurl}
%\usepackage[hyphens]{url}
%\usepackage{multirow}
%\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{listings}
%\usepackage{cite}
%\usepackage{csquotes}
\usepackage[range-phrase=--, range-units=single]{siunitx}
\usepackage{xcolor}
\usepackage[a-3u]{pdfx}
\hypersetup{
    colorlinks,
%    linkcolor={red!50!black},
    linkcolor={black},
%    citecolor={blue!50!black},
    citecolor={black},
%    urlcolor={blue!80!black}
    urlcolor={blue!80!black}
}

\DeclareMathOperator{\rot}{rot}
\DeclareMathOperator{\divergence}{div}

\sloppy % Margón túllógó sorok tiltása.
\widowpenalty=10000 \clubpenalty=10000 %A fattyú- és árvasorok elkerülése
\def\hyph{-\penalty0\hskip0pt\relax} % Kötőjeles szavak elválasztásának engedélyezése

\frenchspacing
\pagestyle{plain} 

%\listfiles % a package-ek kilistázása a logba

\title{
    \centering
    \includegraphics[width=0.48\textwidth]{kep/bme_logo.pdf} \\
    \vspace{0.5cm}
    \large{\bf Budapesti Műszaki és Gazdaságtudományi Egyetem \\
    Villamosmérnöki és Informatikai Kar \\
    Szélessávú Hírközlés és Villamosságtan Tanszék}\\
    \vspace{4cm}
    \large{Önálló laboratórium 2 dolgozat} \\
    \vspace{2cm}
    \Large{\bf{Modell-redukció alkalmazása az elektromágneses térszámításban}} \\
    \vspace{2cm}
}

\parskip=10pt
\parindent=0pt

\newcommand\adj[1]{#1^{\mathrm{H}}}

\author{Szilágyi Gábor \\\vspace{2cm}\\ Konzulens: Dr. Bilicz Sándor}
\date{Budapest, \today}


\begin{document}
    \maketitle
    \setcounter{page}{2}
    \section{Bevezetés}
            A POD, vagyis a Proper Orthogonal Decomposition, egy bázistranszformációs eljárás, ami egy adott adathalmaz reprezentálásához optimális bázist keres meg. Az eljárás által meghatározott $\Psi$ bázisban a bázisvektoroknak az a tulajdonsága, hogy a lehető legkevesebb bázisvektorral leírható az adathalmaz információtartalmának vagy energiájának lehető legnagyobb része. Ezt felhasználva a $\Psi$ csonkításával egy $\Psi'$ közelítő bázist lehet előállítani, ami lényegesen kisebb rendű, mint $\Psi$, mégis kis hibával reprezentálható benne az eredeti adathalmaz. Természetesen minél több bázisvektort hagyunk meg $\Psi'$-ben, annál jobban csökken a modell-redukcióból származó hiba, de a csonkítás mértékét az adott alkalmazáshoz mérten előírhatjuk. A POD egy másik előnyös tulajdonsága, hogy a gyakorlati esetek nagy részében a sorbarendezett $\psi_n$ bázisvektorokra eső energiatartalom rohamosan csökken, ezért sokszor nagyságrendekkel kisebb dimenziószámú bázissal is jól leírható az adathalmaz, mint az eredeti esetben.
        \subsection{A módszer eredete}
            A módszer gyökerei az '40-es évekig nyúlnak vissza, amikor olyan tudományos problémákat próbáltak statisztikai módszerekkel megközelíteni, amelyeknek a megoldása valamilyen folytonos értékű függvény, sok esetben sztochasztikus folyamat. Egy jeles személy ebből a kezdeti időszakból Damodar Dharmananda Kosambi \cite{Kosambi11} indiai matematikus, aki a POD alapját képező (Kosambi--)Karhunen–Lo\`eve Expansion, vagyis Karhunen–Lo\`eve felbontás atyja. A Karhunen–Lo\`eve felbontás sztochasztikus folyamatok olyan reprezentálását teszi lehetővé, ahol a sztochasztikus folyamatot egy végtelen összeg alakjában írjuk fel. Ha ebből az összegből csak az első véges sok $n$ db. tényezőt hagyjuk meg (csonkítjuk a felbontást), akkor a kapott összegnek a lehető legkisebb a négyzetes hibája az eredeti sztochasztikus folyamathoz képest \cite{Aadithya18}.
            \par
            A POD klasszikus formájában végtelen dimenziós vektorterek, azaz függvényterek fölött működik. Valójában numerikusan ennek egy véges dimenziós vektortereken értelmezett megfelelőjét, a szinguláris érték szerinti felbontást (SVD) lehet használni, a féléves munkám során én is ezt az eljárást használtam. A végtelen és véges dimenziós változatok között az átjárást a Galerkin-vetítés teremti meg \cite{Holmes12}.
        \subsection{Felhasználási területekről általában}
            Az eljárást számos tudományterületen sikeresen alkalmazták már, különböző területeken különböző néven szokták emlegetni gyakorlatilag ugyanezt a módszert. Statisztikában főként Principal Component Analysis (PCA) néven fordul elő és nagy adathalmazok információtartalmának kinyerésére használják \cite{Jolliffe16}. Ahogy fent említettem, találkozhatunk még vele az irodalomban Karhunen–Lo\`eve Expansion néven is, elsősorban a sztochasztikus folyamatok kapcsán \cite{Aadithya18}. A turbulens áramlások kutatásával kapcsolatban legtöbbször POD-ként említik \cite{Sirovich}.
            \par
            Lényeges felhasználási területek a fentieken kívül például: szabályozástechnikában a szuboptimális, de gyorsan számítható beavatkozás; nemlineáris elektromágneses problémák (pl. motorok) szimulációja \cite{Henneron14}; genetikában a DNS jellegzetes mintázatainak keresésében \cite{Chicco15}.
        \subsection{Problémakörök}
            A felsorolt problémák, amelyeknél segítséget nyújthat a POD, különböző kategóriákba sorolhatóak.
            \par
            Elsősorban statisztikában merül fel az a gond manapság, hogy egy nagyon sok bejegyzést tartalmazó adathalmaz áll rendelkezésre, amelynek minden bejegyzése sokdimenziós, emiatt az adatok által hordozott információ nehezen hasznosítható. Ez az információkinyerés annak ellenére is problémás, hogy a sok rendelkezésre álló adat összesen sok információt hordoz magában. Ekkor a POD (PCA) segítségével kinyerhetők az adathalmazt jól leíró, jellegzetes mintázatok, amelyek a hasznos információ nagy részét magukban hordozzák.
            \par
            A szimulációk esetében más a helyzet. Itt az jelenti a gondot, hogy a szimulált modell nagyon részletes, például nagyon sok (könnyen $10^6$ -- $10^9$ nagyságrendű) végeselemet tartalmaz, emiatt a szimuláció futtatása sok számítógép erőforrást használ fel. Egyrészt a megoldás memóriában való tárolása is problémás lehet, másrészt a végeselemek módszerénél maradva nagyon nagy egyenletrendszert kell megoldani, ami sok processzoridőt igényel, ami miatt sokáig tart a szimuláció. Ekkor a POD segítségével a ténylegesen megoldandó egyenletrendszer és a megoldás méretét is nagyságrendekkel csökkenteni lehet. Ez úgy történhet, hogy valamilyen előzetes szimuláció eredményét felhasználva az adott modellhez tartozó jellegzetes részmegoldások lineáris kombinációjaként igyekszünk előállítani egy az eredeti modellhez képest is közelítő megoldást, aminek sokkal kisebb az erőforrásigénye.
        \subsection{Alkalmazás az elektromágneses térszámításban}
            \label{sec:empod}
            Az EM térszámításban többféle kontextusban is hasznos lehet a POD a futási idő  vagy a memóriafelhasználás jelentős csökkentésére. Az egyik megközelítésben egy időtartománybeli végeselem modellben zajló tranziens folyamat lefolyására kaphatunk számítás szempontjából olcsó, közelítő megoldást. Ehhez először a teljes kérdéses időintervallum első töredék részére egy teljes értékű szimulációt futtatunk, amely viszonylag sok számítást igényel. Ennek a rövid részmegoldásnak az eredményei szolgálnak a POD bemenetéüli. A POD ezek alapján meghatározza a rendszer dinamikájában megjelenő struktúrákat, majd csak a lényeges összetevőkre szorítkozva egy lecsökkentett szabadsági fokú rendszert szimulálunk tovább a hátralévő időben, ami már időlépésenként sokkal kevesebb számítást igényel.
            \par
            A fent vázolt, tranziens szimulációban történő alkalmazáson kívül más módokon is hasznosítható lehet a POD a térszámítási problémákban, de a dolgozatomban elsősorban ezzel a megközelítéssel foglalkozom. Az alkalmazási lehetőségeket az korlátozza elsősorban, hogy a megoldásnak újrafelhasználhatónak kell lennie egy szimuláció vagy részszimuláció után egy másik futás során. Például egy végeselem szimulációnál ha a térbeli struktúrát megváltoztatjuk, akkor ez majdnem szükségszerűen azzal jár, hogy megváltozik a végeselem-háló, ami miatt már nem igazán lehet újrafelhasználni a korábbi hálóra kapott megoldást. A végeselem szimulációknál a háló mozgásának, változásának lekezelése a Moving Mesh problémakörébe tartozik, a dolgozatomban ezzel nem foglalkozom.
            %TODO
    \section{A POD-ról részletesebben}
    \label{sec:POD}
        A bevezetésben említettem, hogy az adathalmaz energiájának vagy információtartalmának szempontjából optimális a $\Psi$ bázis, de ez pontosításra szorul.
        %TODO pontosítás
        \cite{Jolliffe16}
        \subsection{A felbontás egyenletei}
            A redukálandó adathalmaz méreteitől függően különböző számítási módok optimálisak a POD redukált bázisának előállításához. Az eredeti adathalmazt egy mátrixba rendezzük úgy, hogy az egyes mintákhoz artozó adatok vektorai (${\bf x}_i \in \mathbb{C}^n,~i \in \{1,~\hdots,~k\}$) a mátrix oszlopvektorai legyenek. Az így kapott mátrix (${\bf S}$) a snapshotmátrix vagy mintamátrix:
            \begin{align}
                {\bf S} = & \left[ {\bf x}_1~{\bf x}_2~{\bf x}_3~\hdots~{\bf x}_k \right]
            \end{align}
            Az adott alkalmazástól függ, hogy ${\bf S}$-nek melyik mérete olyan nagy, hogy az gondot jelentsen. \Aref{sec:empod}. részben vázolt nagy szabadsági fokú szimulációknál az okozza a gondot, hogy az egy időlépéshez tartozó ${\bf x}_i$ dimenziószáma -- vagyis $n$ -- nagy, könnyen milliós nagyságrendű, miközben egy jó redukált bázis előállításához, $k \ll n$ db. ${\bf x}_i$ minta elég a dinamikus rendszerből. Ebben az esetben jól használható az ${\bf S}$ szinguláris érték szerinti felbontása (Singular Value Decomposition, SVD):
            \begin{align}
                \label{equ:svd}
                {\bf S}~=&~{\bf U \Sigma \adj{V}}
            \end{align}
        \subsection{A felbontás értelmezése}
            Itt érdemes megállni és értelmezni a felbontásban szereplő mátrixokat és azok jelentését a modellezett rendszerrel kapcsolatban. \Aref{equ:svd}. egyenletben ${\bf U} \in \mathbb{C}^{n\times n}$ lesz a teljes $\Psi$ bázis vektorait (${\bf u}_i,~i \in \{1,~\hdots,~k\}$), mint oszlopvektorokat tartalmazó unitér mátrix. Az ${\bf U}$ mátrixnak csak az első $k$ db. oszlopa hordoz információt az ${\bf S}$ mintamátrixszal kapcsolatban, így csak ezek az oszlopok tartoznak a $\Psi$ bázisba. Az utolsó $n-k$ db. oszlop csak ahhoz kell, hogy ${\bf U}$ unitér mátrix legyen.
            \par
            A ${\bf \Sigma} \in \mathbb{R}^{n\times k}$ egy diagonálmátrix, aminek az $i$-eik diagonáleleme, $\sigma_i$ az ${\bf u}_i$-hez tartozó együttható, ami azt fejezi ki, hogy az adott bázisvektor mennyire fontos, mennyire járul hozzá általában a rendszer állapotához, más szóval a rendszer energiájának vagy információtartalmának mekkora része írható le az adott bázisvektorral. Mivel ${\bf \Sigma}$ általános esetben nem négyzetes, de diagonális, ezért lesz egy olyan részmátrixa, ami csupa 0 értékekkel van feltöltve. Jelen esetben, vagyis ha a $n > k$, akkor az alsó $n-k$ db. sora csupa 0. A ${\bf \Sigma}$ olyan felépítésű az SVD miatt, hogy a diagonálelemek csökkenő sorrendben szerepelnek az átlóban bal fentről jobbra lefelé haladva. A ${\bf U\Sigma} \in \mathbb{C}^{n\times k}$ szorzat tehát már az eredeti adatokhoz skálázott bázisvektorok mátrixának tekinthető, amelyek az oszlopaiban fontosság szerint csökkenő sorrendben szerepelnek. Ez a ${\bf U\Sigma}$ szorzat is olyan, hogy már csak ${\bf U}$ első $k$ db. oszlopa szerepel benne $\sigma_i$-vel skálázva.
            \par
            Tömören összefoglalva a ${\bf \adj{V}}$ mátrix a skálázott bázisvektorokhoz tartozó együtthatók mátrixa. A ${\bf \adj{V}}$ mátrix az $i$-edik ${\bf v}_i$ oszlopában tartalmazza az ${\bf x}_i$ mintavektor előállításához szükséges együtthatókat, amelyek a ${\bf U\Sigma}$ szorzat oszlopait súlyozzák:
            \begin{align}
                {\bf x}_i~=&~{\bf U\Sigma v}_i
            \end{align}
            Más szemszögből megközelítve a ${\bf \adj{V}}$ értelmezését, $v_{j,i}$, tehát ${\bf \adj{V}}$ $j$-edik sorának $i$-edik eleme (${\bf v}_i$ $j$-edik eleme) jelenti ${\bf u}_j \sigma_j$ hozzájárulását vagy súlyát ${\bf x}_i$-hez.
            \par
            Az ellenkező esetben, amikor $k\gg n$, már számításigény szempontjából nem optimális ${\bf S}$ teljes SVD-jének direkt kiszámolása, mert ez az immár $k \times k$ méretű ${\bf \adj{V}}$ mátrix kiszámolásával jár, ami a redukált modell létrehozása szempontjából lényegtelen. Ebben az esetben érdemesebb lenne kiszámítani az adathalmaz kovarianciamátrixát, a ${\bf C} \in \mathbb{C}^{n \times n}$ mátrixot. Azért jutunk ezzel előrébb, mert \aref{equ:kovariancia}. egyenletben látható módon az ${\bf U}$ mátrixot megkaphatjuk a ${\bf C}$ spektrálfelbontásából is. Ezzel a módosított eljárással Method of Snapshots néven találkozhatunk az irodalomban \cite{Chatterjee00}. Mivel ${\bf C}$ szimmetrikus, ezért pozitív definit, emiatt mindig létezik spektrálfelbontása.
            \begin{align}
            \begin{split}
                \label{equ:kovariancia}
                {\bf C}~=&~{\bf S \adj{S}} \\
                =&~{\bf U \Sigma \adj{V} V\Sigma \adj{U}} \\
                =&~{\bf U \Sigma}^2{\bf \adj{U}}
            \end{split}
            \end{align}
            Itt ${\bf S}$ a snapshot-mátrix, ${\bf U}$ oszlopai az új bázisvektorok, ${\bf \Sigma}$ tartalmazza a bázisvektorok információtartalmát jellemző szinguláris értékeket a főátlójában, ${\bf \adj{V}}$ sorai az egyes bázisvektorok időfüggő együtthatói, ${\bf C}$ pedig az ${\bf x}_i$ mintavektorokból álló adathalmaz kovarianciamátrixa.
        \subsection{Az SVD takarékos változatai}
            Az SVD algoritmusnak többféle változata ismert, amelyek mind műveletszám, mind memóriahasználat terén takarékosabbak a teljes SVD-nél. Ahogy már fent is említettem, a redukált bázis meghatározása szempontjából a ${\bf V}$ mátrix kiszámolása érdektelen. Ezen kívül, ha előre adott egy határ, hogy legalább mekkora szinguláris értékhez tartozó bázisvektorokat tartsunk meg, akkor ennél a határnál kisebb szinguláris értékekhez tartozó oszlopok ${\bf U}$-ban, illetve sorok $\adj{{\bf V}}$-ban érdektelenek. Ez a határ a szinguláris értékekre vonatkozóan lehet abszolút vagy relatív is, célszerűen a legnagyobb szinguláris értékhez képest. A számítógépek véges pontosságú számábrázolása miatt az is előfordulhat, hogy egy felbontani kívánt mátrix rangja lényegesen kisebb, mint a numerikus ábrázolási hibákkal terhelt megfelelőjéé. Más szóval a numerikus rangja eltér a valódi rangtól. Ez indokolttá teszi egy hibahatár bevezetését, aminél kisebb számokat már csak numerikus hibának tekintünk és emiatt pontosan 0-val helyettesítjük őket.
            \par
            Az SVD algoritmusnak többféle implementációja elérhető, némelyiknek pedig megadhatóak további paraméterek, amelyekkel például a fent vázolt, szinguláris értékekre vagy ábrázolási pontosságra vonatkozó határokat lehet megadni, továbbá egy fix redukált rangot is. Elvileg az is megadható, hogy az ${\bf U}$ és ${\bf \adj{V}}$ mátrixok közül melyikre van szükségünk, eszerint a nem szükségesnek megadott mátrix nem számolódik ki teljesen, ami egyes esetekben nagy csökkenéssel járhat erőforrásigény tekintetében \cite{Golub70}.
            \par
            A takarékos SVD változatok \aref{fig:reduced_svd_sajat}. ábrán láthatóak olyan esetben, amikor $k < n$. Ezen belül a teljes SVD az, aminél ${\bf \Sigma}$ ugyanolyan méretű, mint a felbontott ${\bf S}$ mátrix, ezzel a változattal írtam fel előzőleg a mintamátrix felbontását (\ref{fig:reduced_svd_sajat_1}. ábra).
            \par
            A kompakt SVD az, amit \aref{sec:POD}. szakaszban felvázoltam (\aref{fig:reduced_svd_sajat_1}. ábra). Ez a következőkben különbözik a teljes SVD-től. Éljünk a következő elnevezeéssel: $m=min(n,k)$. A ${\bf U}$ mátrixból kihagyjuk azokat az oszlopokat, amelyekhez nem tartozik sem szinguláris érték, sem ${\bf \adj{V}}$-beli oszlop, és hasonlóan ${\bf \adj{V}}$ soraival is, de az ${\bf U}$ és ${\bf \adj{V}}$ mátrixok közül egyszerre csak az egyiknek a megcsonkítására van szükség $n$ és $k$ viszonyától függően. Ezen kívül a ${\bf \Sigma}$ mátrixnak is kihagyjuk a csupa 0 részét, amely az utolsó $n-m$ sora vagy az utolsó $k-m$ oszlopa, így egy $m \times m$ méretű diagonálmátrix lesz belőle, aminek minden diagonáleleme egy szinguláris érték. Ekkor a kompakt SVD-ben ${\bf U_k} \in \mathbb{C}^{n\times m}, {\bf\Sigma_k} \in \mathbb{C}^{m\times m}, {\bf \adj{V_k}} \in \mathbb{C}^{m\times k}$. A kompakt SVD a teljes változathoz képest nem jár információveszteséggel ${\bf S}$-re nézve. Az SVD-nek ez a változata használható MATLAB-ban, ha megadjuk az \verb|svd()| függvénynek a \verb|`econ`| opciót.
            \par
            A vékony SVD egy következő redukcióval jön létre a kompakt változatból. A kompakt SVD esetén még a szinguláris értékek között lehetnek 0 értékűek, amelyek a ${\bf \Sigma_v}$ főátlójának utolsó elemei. Tegyük fel, hogy $l$ db. nemnulla szinguláris érték van. A 0 szinguláris értékekhez tartozó ${\bf U_v}$-beli oszlopok és ${\bf \adj{V_v}}$-beli sorok szintén nem hordoznak hasznos információt, így ezektől is meg lehet szabadulni, valamint ${\bf \Sigma_v}$-ból is elég csak azt az $l\times l$-es bal felső részmátrixot megtartani, aminek a főátlójában a nemnulla szinguláris értékek vannak. Ekkor ${\bf U_v} \in \mathbb{C}^{n\times l}, {\bf \Sigma_v} \in \mathbb{C}^{l\times l}, {\bf \adj{V_v}} \in \mathbb{C}^{l\times k}$. Mivel itt már azt vizsgáljuk, hogy a szinguláris értékek 0 értékűek-e, felmerül az árbázolási hiba kérdése, ami miatt tévesen sokkal több szinguláris értéket is pozitívnak vélhet az algoritmus, mint amennyi valójában jelentős méretű. Erre a problémára nyújt megoldást az ábrázolási hibahatár megadása. Még ez a változat sem jár információvesztéssel, de az ábrázolási hibahatár használata miatt más numerikus pontatlanságból adódó zaj fogja terhelni a vékony SVD felbontásból visszaállított ${\bf S}$ mátrixot, mint az előző két esetben.
            \par
            Végül pedig a csonkított változat olyan, hogy csak a legnagyobb $r$ db. szinguláris érték, valamint az ezekhez tartozó ${\bf U}$-beli oszlopok és ${\bf \adj{V}}$-beli sorok számolódnak ki. Az $r$ szám egy előre megadott konstans. Ekkor ${\bf U_c} \in \mathbb{C}^{n\times r}, {\bf \Sigma_c} \in \mathbb{C}^{r\times r}, {\bf \adj{V_c}} \in \mathbb{C}^{r\times k}$. Ebben az esetben már az ${\bf S}$ mátrixnak csak egy kisebb rangú reprezentációja, ${\bf \tilde{S}}$ állítható elő a ${\bf U_c \times\Sigma_c\times\adj{V_c}}$ szorzatként.
            \begin{figure}[h]
                \centering
                \begin{subfigure}{0.48\textwidth}
                    \includegraphics[width=\textwidth]{kep/reduced_svd_sajat_1.pdf}
                    \caption{Teljes SVD.}
                    \label{fig:reduced_svd_sajat_1}
                \end{subfigure}
                \begin{subfigure}{0.48\textwidth}
                    \includegraphics[width=\textwidth]{kep/reduced_svd_sajat_2.pdf}
                    \caption{Kompakt SVD.}
                    \label{fig:reduced_svd_sajat_2}
                \end{subfigure}
                \begin{subfigure}{0.48\textwidth}
                    \includegraphics[width=\textwidth]{kep/reduced_svd_sajat_3.pdf}
                    \caption{Vékony SVD.}
                    \label{fig:reduced_svd_sajat_3}
                \end{subfigure}
                \begin{subfigure}{0.48\textwidth}
                    \includegraphics[width=\textwidth]{kep/reduced_svd_sajat_4.pdf}
                    \caption{Csonkított SVD.}
                    \label{fig:reduced_svd_sajat_4}
                \end{subfigure}
                \caption{Az SVD különböző változatai \cite{WikipediaSVD}.}
                \label{fig:reduced_svd_sajat}
            \end{figure}
            %TODO wikipedia szerint thin, compact és truncated. Lehet, hogy föntebb is át kéne írni, hogy hogy érdemes kiszámolni
    \section{Példa szimuláció}
        A POD működésének demonstrálására a konzulensem, Dr. Bilicz Sándor segítségével írtam egy MATLAB szkriptet. A szkript egy egydimenziós véges differencia közelítést használó modell tranziens viselkedését szimulálja, pontosabban az elektromos és mágneses tér alakulását. A megoldást többféleképpen számítja ki, teljes és redukált bázisú változatban is, hogy ezek összehasonlíthatóak legyenek.
        \subsection{A modell}
            A szimulációval egy kör keresztmetszetű, $a$ sugarú, végtelen hosszú, véges vezetőképességű vezetőben létrejövő mágneses és elektromos teret vizsgáltam. \Aref{fig:modell}. ábrán látható módon áll össze a modell. 
            \par
            \begin{figure}[h]
                \centering
                \includegraphics[width=0.48\textwidth]{kep/modell.pdf}
                \caption{A szimulált modell}
                \label{fig:modell}
            \end{figure}
             A vezető rúd keresztmetszete a szaggatottal jelölt kör. A vezető hengernek $\sigma$ fajlagos vezetése és $\mu=\mu_0$ permittivitása van, mindkét mennyi. A használt henger-koordinátarendszer bázisvektorai ${\bf e}_{z}, {\bf e}_{\varphi}$ és ${\bf e}_{r}$. A vezető henger szimmetriatengelye $z$-irányú és szintén $z$-irányú benne a felületi áramsűrűség vektora is, ez az áramsűrűség a vezető hossza mentén nem változik. A modell általában $z$-irányú eltolásra és a szimmetriatengely körüli ($\varphi$ irányú) forgatásra invariáns, emiatt csak az egyes mennyiségek $r$ sugártól való függését kell vizsgálni, emiatt egydimenziós a modell.
             \par
             A vezető keresztmetszetére elő van írva az összesített áram időfüggvénye, $I(t)$, de a skin-hatás miatt a vezető belsejében nem egyenletes az áramsűrűség, hanem a sugár mentén haladva változik. Ugyanígy a vezető belsejében létrejövő $H_\varphi$ és $E_z$ is függ a sugártól. Ezek a mennyiségek továbbá időfüggőek is, de a vezető henger önindukciója miatt nem pontosan a gerjesztéssel együtt változnak. Ezeknek a mennyiségeknek az időbeli alakulása a kérdés, ezeket határozza meg a szimuláció egy adott gerjesztés mellett.
            \par
            A modell például egy villámhárító földelő vezetőjében létrejövő elektromágneses tér alakulásának a vizsgálatára használható, amikor a villám meghatározza a villámhárítón folyó áramot.
        \subsection{A számítás menete}
            A félév során készített szimuláció a következőképpen épül fel.
            \par
            A rendszer 0 kezdeti állapotból indul, tehát kezdetben a hengerben nem folyik áram és emiatt 0 benne a mágneses és elektromos térerősség is. Az eredő $I(t)$ olyan formában van előírva, hogy a vezető felületére adott a mágneses térerősség időfüggvénye, vagyis $H_{\varphi}(r=a,t)$.
            \par
            Kétféle időlépéses módon készül megoldás a problémára, az egyik egy egyszerű előrelépő Euler sémát használ, a másik pedig a MATLAB beépített \verb|ode45()| függvényét, ami Runge-Kutta sémára épül és adaptív az időlépése. Mindkét megoldástípushoz szükség van arra, hogy a rendszer adott pillanatbeli állapotából, amit $H_{\varphi}(r,t)$ teljesen leír, ki lehessen számítani $H_{\varphi}$ idő szerinti parciális deriváltját. Ennek a parciális deriváltnak a segítségével aztán lehet előre léptetni az időlépéses sémákat, amiből egy $\Delta t$ idővel későbbi $H_{\varphi}(r,t+\Delta t)$ állapot adódik.
            \begin{align}
                \label{equ:fe}
                H_{\varphi}(r,t+\Delta t) \approx & \dfrac{\partial H_{\varphi}(r,t)}{\partial t} \cdot \Delta t
            \end{align}
            Az előrelépő Euler séma időléptetése \aref{equ:fe}. egyenletben látható. Ez az időlépéses séma könnyen használhatatlan lesz, ha rosszul választjuk meg a térbeli diszkretizáló távolságot, ($\Delta r$), valamint az időlépés hosszát ($\Delta t$). A szimuláció előtt a szkript konvergenciavizsgálatot végez, amihez a következő képletet használja:
            \begin{align}
                F &= \dfrac{\alpha \Delta t}{\Delta r^2}, \quad \alpha = \dfrac{1}{\mu \sigma}
            \end{align}
            A megoldás csak akkor konvergens, vagyis használható, ha $F<0.5$.
            \par
            A Maxwell-egyenleteknek a modellben használt alakja \aref{equ:maxwell}. egyenletben látható (magneto-kvázistacionárius közelítés).
            \begin{equation}\label{equ:maxwell}
                \begin{aligned}
                \rot \textbf{H}~&=~{\bf J} \\
                \rot \textbf{E}~&=~-\dfrac{\partial \textbf{B}}{\partial t} \\
                \divergence \textbf{B}~&=~0 \\
                \divergence \textbf{E}~&=~0 \\
                \textbf{B}~&=~\mu \textbf{H} \\
                \textbf{J}~&=~\sigma\textbf{E} + \textbf{J}_i
                \end{aligned}
            \end{equation}
            Mivel a hengerre az összáram időfüggvénye adott, így ezzel együtt a felszíni mágneses térerősség is adott.
            \par
            \begin{figure}[h]
                \centering
                \includegraphics[width=0.48\textwidth]{kep/euler_0.15_4_td.eps}
                \caption{A szimulált modell}
                \label{fig:modell}
            \end{figure}
            \begin{figure}[h]
                \centering
                \includegraphics[width=0.48\textwidth]{kep/ode45_0.15_4_td.eps}
                \caption{A szimulált modell}
                \label{fig:modell}
            \end{figure}
            \begin{figure}[h]
                \centering
                \includegraphics[width=0.48\textwidth]{kep/euler_0.07_4_td.eps}
                \caption{A szimulált modell}
                \label{fig:modell}
            \end{figure}
            \begin{figure}[h]
                \centering
                \includegraphics[width=0.48\textwidth]{kep/euler_0.07_8_td.eps}
                \caption{A szimulált modell}
                \label{fig:modell}
            \end{figure}
            \begin{figure}[h]
                \centering
                \includegraphics[width=0.48\textwidth]{kep/euler_0.15_2_td.eps}
                \caption{A szimulált modell}
                \label{fig:modell}
            \end{figure}
            \begin{figure}[h]
                \centering
                \includegraphics[width=0.48\textwidth]{kep/euler_0.15_4_base_1_4.eps}
                \caption{A szimulált modell}
                \label{fig:modell}
            \end{figure}
            \begin{figure}[h]
                \centering
                \includegraphics[width=0.48\textwidth]{kep/euler_0.15_4_base_11_14.eps}
                \caption{A szimulált modell}
                \label{fig:modell}
            \end{figure}
            \begin{figure}[h]
                \centering
                \includegraphics[width=0.48\textwidth]{kep/euler_0.15_4_rel_error.eps}
                \caption{A szimulált modell}
                \label{fig:modell}
            \end{figure}
            \begin{figure}[h]
                \centering
                \includegraphics[width=0.48\textwidth]{kep/euler_0.15_4_rel_max_error.eps}
                \caption{A szimulált modell}
                \label{fig:modell}
            \end{figure}
            \begin{figure}[h]
                \centering
                \includegraphics[width=0.48\textwidth]{kep/euler_0.15_4_sv.eps}
                \caption{A szimulált modell}
                \label{fig:modell}
            \end{figure}
            \begin{figure}[h]
                \centering
                \includegraphics[width=0.48\textwidth]{kep/euler_0.15_4_ez_waterfall.eps}
                \caption{A szimulált modell}
                \label{fig:modell}
            \end{figure}
            \begin{figure}[h]
                \centering
                \includegraphics[width=0.48\textwidth]{kep/euler_0.15_4_hphi_waterfall.eps}
                \caption{A szimulált modell}
                \label{fig:modell}
            \end{figure}
            \newpage
    \bibliography{mybib}
    \bibliographystyle{plain}
\end{document}

%\cite{Henneron14}

%            \begin{figure}
%                \centering
%                \includegraphics[width=0.8\textwidth]{kep/szerkesztett/wstk-mighty-gecko-nagy.jpg}
%                \caption{WSTK + radio board.}
%                \label{fig:wstkmighty}
%            \end{figure}
% \cite{Anritsu}
%            \begin{figure}
%                \centering
%                \begin{subfigure}{0.48\textwidth}
%                    \includegraphics[width=\textwidth]{kep/szerkesztett/sol-868-conducted.png}
%                    \caption{\SI{868}{MHz}}
%                \end{subfigure}
%                \begin{subfigure}{0.48\textwidth}
%                    \includegraphics[width=\textwidth]{kep/szerkesztett/sol-470-conducted.png}
%                    \caption{\SI{470}{MHz}}
%                \end{subfigure}
%                \caption{470 és \SI{868}{MHz}-es Sol radio board-ok kimeneti spektruma.}
%                \label{fig:sol-conducted}
%            \end{figure}

